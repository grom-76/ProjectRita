<h1>The new Vulkan Coordinate System</h1>
<h3><a href="/">Matthew Wellings</a> 20-Mar-2016</h3>
<p>Vulkan introduces a number of interesting changes over OpenGL with some of the key performance and flexibility changes being mentioned often on the internet. A more subtle yet equally important change to be understood is the that of the coordinate system.</p>
<p>The first change of note is that the y axis now points down the screen. The x and z axes point in the same direction as before. This means that if you do not correct for this two notable things happen. Firstly your image will be flipped. Secondly your face culling order will be backwards. There are multiple ways of resolving this. The method used in the samples is to simply add the following line to all vertex shaders:</p>
<pre><code>gl_Position.y = -gl_Position.y;</code></pre>
<img src="images\coordinateDiagram.png" width="471" height="131" alt="Coordinate System Diagram">
<p class="caption">In OpenGL we had a left-hand NDC space, in Vulkan we have a right hand NDC space (assuming depth clear value is 1 and depth function is GL_LEQUAL / VK_COMPARE_OP_LESS_OR_EQUAL).</p>
<p>The other change to the coordinate system is to the z axis i.e. the depth range.
After the programmable vertex stage a set of fixed function vertex operations are run. During this process your homogeneous coordinates in clip space are divided by w<sub>c</sub> (to give NDC space) and then transformed into window space (now called framebuffer space).
</p>
<p>The divide by w<sub>c</sub> is the first of these two steps and has not changed but the transformation into window space has.</p>
<p>OpenGL expected a final depth range for z<sub>w</sub> of [0-1]. The standard perspective projection matrix transforms points on the near plane to have a z<sub>d</sub> value of -1 and points on the far plane to have a z<sub>d</sub> of 1.<br>
These were placed into the range [0-1] by the transform into window space. In OpenGL this transform was defined as:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow> <mo>(</mo> <mtable> <mtr> <mtd> <msub> <mi>x</mi> <mi>w</mi> </msub> </mtd> </mtr> <mtr> <mtd> <msub> <mi>y</mi> <mi>w</mi> </msub> </mtd> </mtr> <mtr> <mtd> <msub> <mi>z</mi> <mi>w</mi> </msub> </mtd> </mtr> </mtable> <mo>)</mo> </mrow> <mo>=</mo> <mrow> <mo>(</mo> <mtable> <mtr> <mtd> <mfrac> <msub> <mi>p</mi> <mi>x</mi> </msub> <mn>2</mn> </mfrac> <msub> <mi>x</mi> <mi>d</mi> </msub> <mo>+</mo> <msub> <mi>o</mi> <mi>x</mi> </msub> </mtd> </mtr> <mtr> <mtd> <mfrac> <msub> <mi>p</mi> <mi>y</mi> </msub> <mn>2</mn> </mfrac> <msub> <mi>y</mi> <mi>d</mi> </msub> <mo>+</mo> <msub> <mi>o</mi> <mi>y</mi> </msub> </mtd> </mtr> <mtr> <mtd> <mfrac> <mrow> <mi>f</mi> <mo>-</mo> <mi>n</mi> </mrow> <mn>2</mn> </mfrac> <msub> <mi>z</mi> <mi>d</mi> </msub> <mo>+</mo> <mfrac> <mrow> <mi>n</mi> <mo>+</mo> <mi>f</mi> </mrow> <mn>2</mn> </mfrac> </mtd> </mtr> </mtable> <mo>)</mo> </mrow>  </math>
<p>Where z<sub>d</sub> is z<sub>clip</sub>/w<sub>clip</sub> and f and n were set using glDepthRange(double n, double f). The default values of n and f were 0 and 1 respectively. Substituting in these defaults the z component of this transform simplifies to ½z<sub>d</sub> + ½.</p>
<p>In Vulkan the transform is now defined as:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow> <mo>(</mo> <mtable> <mtr> <mtd> <msub> <mi>x</mi> <mi>f</mi> </msub> </mtd> </mtr> <mtr> <mtd> <msub> <mi>y</mi> <mi>f</mi> </msub> </mtd> </mtr> <mtr> <mtd> <msub> <mi>z</mi> <mi>f</mi> </msub> </mtd> </mtr> </mtable> <mo>)</mo> </mrow> <mo>=</mo> <mrow> <mo>(</mo> <mtable> <mtr> <mtd> <mfrac> <msub> <mi>p</mi> <mi>x</mi> </msub> <mn>2</mn> </mfrac> <msub> <mi>x</mi> <mi>d</mi> </msub> <mo>+</mo> <msub> <mi>o</mi> <mi>x</mi> </msub> </mtd> </mtr> <mtr> <mtd> <mfrac> <msub> <mi>p</mi> <mi>y</mi> </msub> <mn>2</mn> </mfrac> <msub> <mi>y</mi> <mi>d</mi> </msub> <mo>+</mo> <msub> <mi>o</mi> <mi>y</mi> </msub> </mtd> </mtr> <mtr> <mtd> <msub> <mi>p</mi> <mi>z</mi> </msub> <mo>&#xD7;</mo> <msub> <mi>z</mi> <mi>d</mi> </msub> <mo>+</mo> <msub> <mi>o</mi> <mi>z</mi> </msub> </mtd> </mtr> </mtable> <mo>)</mo> </mrow> </math>

<p>Where z<sub>d</sub> is still z<sub>clip</sub>/w<sub>clip</sub>, p<sub>z</sub> = maxDepth-minDepth and o<sub>z</sub> = minDepth. The maxDepth and minDepth values are as set in your VkViewport.</p>
<p>If you have your minDepth and maxDepth to 0 and 1 respectively, your near plane will be at -2fn/(f+n) where f and n are the near and far parameters used to create your perspective matrix (probably not what you want).</p><p>Many Vulkan demos do set the minDepth and maxDepth to 0 and 1 respectively and use another line of code at the end of the vertex shader:</p>
<p><pre><code>gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;</code></pre>
<p>This code works because once you divide (z<sub>c</sub>+w<sub>c</sub>)/2 by w<sub>c</sub> and rearrange you get z<sub>d</sub> = ½(z<sub>c</sub>/w<sub>c</sub>) + ½.<br>
Applying the Vulkan transform of p<sub>z</sub> * z<sub>d</sub> + o<sub>z</sub> with p<sub>z</sub>=1, and o<sub>z</sub>=0 you still get z<sub>f</sub> = ½(z<sub>c</sub>/w<sub>c</sub>) + ½. This is the same transform as OpenGL with default depth range.</p>

<p>It is also worth mentioning that so-far we have only discussed the final window/framebuffer coordinates & depth range. These are used for bounding, storage and testing. There is also the clipping stage which happens in homogeneous clip space (immediately after the vertex shader, before the divide by w<sub>c</sub>). OpenGL defined its clip volume's z bounds as -w<sub>c</sub> ≤ z<sub>c</sub> ≤ w<sub>c</sub> but they are now defined in Vulkan as 0 ≤ z<sub>c</sub> ≤ w<sub>c</sub>. 
Using this line in your shader will also give the correct values in clip space as it shifts points on the near plane to z<sub>c</sub>=0. </p>
<p>There are some alternatives to adding these lines to the end of your vertex shaders. One of these is to pre-multiply your projection matrix by the following correction matrix:</p>
<math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow> <mo>[</mo> <mtable rowspacing="4pt" columnspacing="1em"> <mtr> <mtd> <mn>1</mn> </mtd> <mtd> <mn>0</mn> </mtd> <mtd> <mn>0</mn> </mtd> <mtd> <mn>0</mn> </mtd> </mtr> <mtr> <mtd> <mn>0</mn> </mtd> <mtd> <mn>-1</mn> </mtd> <mtd> <mn>0</mn> </mtd> <mtd> <mn>0</mn> </mtd> </mtr> <mtr> <mtd> <mn>0</mn> </mtd> <mtd> <mn>0</mn> </mtd> <mtd> <mn>1</mn> <mrow class="MJX-TeXAtom-ORD"> <mo>/</mo> </mrow> <mn>2</mn> </mtd> <mtd> <mn>1</mn> <mrow class="MJX-TeXAtom-ORD"> <mo>/</mo> </mrow> <mn>2</mn> </mtd> </mtr> <mtr> <mtd> <mn>0</mn> </mtd> <mtd> <mn>0</mn> </mtd> <mtd> <mn>0</mn> </mtd> <mtd> <mn>1</mn> </mtd> </mtr> </mtable> <mo>]</mo> </mrow> </math>
<p>The resulting corrected projection matrix is mathematically equivalent to using these two shader lines but does not require the additional GPU overhead.<p>LunarG have an <a href="https://github.com/LunarG/VulkanSamples/commit/0dd36179880238014512c0637b0ba9f41febe803">example of the use of this matrix</a> in their Hologram demo.</p>
<p>If you are using Glm you may be interested in the new define <a href="https://github.com/g-truc/glm/commit/f48fe286ad88f9ffd5c5e9f0d95a6cd1107ac40b">GLM_FORECE_DEPTH_ZERO_TO_ONE</a>. This define will give you the correct depth range but still leave the y direction reversed.</p>
